---
title: 永别，MHC！
date: 2019-02-02 23:55:48 +0800
categories:
  - life
tags:
  - frontend-engineer
  - job
  - maihaoche
banner:
  url: drafts/say-goodbye-to-maihaoche/banner.jpg
  description: 办公室
---

一般情况下，在谈论一家公司时所用的称呼是它的主打产品/品牌的名字，而非真正的注册名称。「MHC」就是我工作过的一家公司的主打产品/品牌的拼音「mai hao che」的首字母缩写。之所以不直接用汉字来指代，是因为在我任职期间它发生过转型——从自己卖车的「买好车」变成帮别人卖车的「卖好车」。

「MHC」的创始团队基本都来自淘宝，CEO 胡斐曾是蘑菇街 CMO，光看这点，这家创业公司会给人一种比较靠谱的感觉。在快 3 年的时间里，隔壁的公司一个接一个倒在了寒冬中，园区成了创业公司的坟场，而「MHC」依然顽强地活着，宛如一朵不惧寒风的花。这么来看，这家公司还真挺靠谱的。

然而，就是这样一家外人觉得靠谱的公司，在 2018 年 7 月，我离职了。

## 初瞥

2015 年 9 月，我离开了待了两年多却在各方面看不到任何希望的一家做在线教育的公司。找工作时面试的几家公司基本都给了 offer，综合考虑了薪酬待遇、发展空间和行业前景等因素，最终选择「MHC」。

到新公司报到与从上家公司离职只隔了一个周末。入职那天，我起得特别早。这天不仅是新工作的开始，也是我人生一个新阶段的开始，心情非常愉快、激动。

从住处走到文一西路上的「枫树湾河桥」公交站，和去阿里巴巴西溪园区上班的人挤同一辆公交车上班，别有一番感觉。连曾经被我嫌弃远在天边的仓前，现如今也觉得近在眼前。下车后，看到园区门口刻着「梦想小镇」四个字的大石头，不禁掏出手机拍张照片发到朋友圈：「梦想小镇，实现梦想的地方。」

走进公司大门，经前台指引去办理手续，原来那天入职的不只我一个人。其中一个环节是取花名，因为创始团队大多来自淘宝，继承了阿里的花名文化也是理所当然。在没有准备的情况下，取花名对大部分人来说都是件头疼的事，我直接拿之前构思的小说主人公的名字作为自己的花名——欧雷。

各种填表签字之后，把背包放到工位，屁股还没坐热乎就被 leader 拉着整个大办公区里遛了一圈——「这是万剑」「这是拓爷」「这是大表哥」……把包括设计师和产品经理在内的研发部门的二、三十号人都认了个遍。回到工位再跟前端团队的其他人认识了一下，发觉比我面试时所得知的人数多了一个，算我 5 个人。

在用 Git 把代码拉下来，了解了正在使用的技术、开发方式和分支管理方式等信息之后，发现这里还挺落后的……与当时的主流差一截，并且有些不合理的地方。虽然使我震惊，但并未让我失望，心中反而燃起熊熊希望之火——我暗下决心，一定要改善现状！

## 既有的前端

### 神奇的 Git 仓库

我克隆的第一个 Git 仓库（以下简略为「仓库」）是一个神奇的仓库，因为它的名字和构成。

由于公司的业务是与汽车相关的，大部分仓库以汽车品牌来命名，个别非业务应用的以代表其功能的英文单词命名。而这个仓库的名字叫 `shanshan`，很明显不是一个汽车品牌，也不是一个功能性的语义化命名，而是人名或其他什么东西的名字的拼音。

在询问了 leader 之后才知道，他是这家公司的第二个前端工程师，在他之前还有一个花名叫「陕陕」的女前端工程师，`shanshan` 就是她以自己的花名拼音创建的。她是这里的第一个前端工程师，也是第一个女的前端工程师，后来回家休产假了。这位素未谋面的「第一女前端」曾在成立初期的蘑菇街工作过，也是那里的「第一女前端」。

一般来说，业务应用的仓库应该是「一个萝卜一个坑」，即一个仓库对应一个应用，无论前、后端的代码是否在一起。在这里，后端代码是按照这个规则来划分仓库的，可前端代码是把所有应用的都放到了 `shanshan` 这个仓库里，简直就是个「大杂烩」！

致使 `shanshan` 变得如此臃肿失控，大概是因为：

1. 采用了「前后端分离」的开发方式；
2. 野蛮生长期，不注重规范、工程问题；
3. 前端没什么话语权。

这个仓库存在的问题不仅如此：

* 第三方库都是从网上直接下载的，没有用 Bower、NPM 等进行依赖管理；
* 虽说引入了 Gulp 处理代码和文件，但样式的源码用的还是 CSS，而不是 Sass、LESS、Stylus 之类的预处理语言，也没有用 PostCSS 进行后处理；
* 分支管理混乱，这是整个技术部的通病；
* ……

虽然嘴上在吐槽，但心里是高兴的，这不就是让我施展拳脚的机会吗？那就愉快地决定拿它开刀了！

### 奇特的开发方式

这里采用了「前后端分离」的开发方式，但跟大家所理解的有所不同——

公司的后端语言是 Java，所使用的 web 框架是阿里巴巴自研的 [Webx](http://webx.github.io/){:target="_blank"}{:rel="nofollow external"}，相应的后端代码 Git 仓库中没有任何图片、CSS、JS 等静态资源文件，它们全部在 `shanshan` 这个神奇的仓库中。

在开发新功能时，需要在 IntelliJ IDEA 中通过 Tomcat 启动 Java 服务来查看页面和调用接口，页面中静态资源文件的 URL 全部为线上地址，即使文件不存在，再通过代理将线上地址映射到本地文件。当功能开发完成，就用 leader 写的一个基于 Node.js 的命令行工具把相关静态资源文件上传到[七牛](https://www.qiniu.com/){:target="_blank"}{:rel="nofollow external"}。这时，将映射文件的代理规则去掉或让后端开发人员打开页面就能够正常访问了。

这个命令行工具没有将要上传的文件地址提取到配置文件中，而是直接写在脚本文件里，并且没有按指定规则过滤文件的功能，等要上传的文件一多，简直麻烦得不得了……

这种 HTML 代码写在 web 框架的后端模板中，单纯把静态资源文件分离出去的做法，在我看来既低效又毫无意义。

## 团队内首次分享

由于 `shanshan` 这个仓库中已经存在大量文件，也就是所谓的「历史问题」，在目录结构方面不好做大的调整了，只好听之任之。但在分支管理和源码编写上，还是能够做些改变的。针对这两方面，我在入职没多久时的一次前端团队的周会上分享了前公司所使用的相对先进的思想、方法和工具。

### Git 分支管理

这里原有的分支管理方式是——

<blockquote>
  <p>每周有两个固定的发布日，在每个发布日之前某个管理发布的测试工程师（是的，我们没有运维工程师）会基于 <code>master</code> 分支创建前缀为 <code>pub_</code> 的发布分支，在发布之前会将要发布的内容都汇总在这个分支上进行测试，通过后再合并到 <code>master</code> 分支上进行发布。然而，发布完不会立刻将那个分支删掉，而是要保留几个星期以避免出问题。这样就会有好多过期的分支留在那里。</p>
  <p>有些不是立刻发布的内容，后端工程师们就会自己基于 <code>master</code> 分支创建出 <code>dev_</code> 为前缀的分支来开发新内容。</p>
  <footer>欧雷《<cite><a href="/posts/engineering-problems-of-frontend-development/" target="_blank">前端工程优化之路</a></cite>》</footer>
</blockquote>

这种方式的缺点主要有：

* 没有用于做线上 bug 修复的分支；
* 没有使用 Git 的标签功能做发布版本标记，从而残留大量冗余分支；
* 只有一个主要分支，查看历史版本信息不方便，并且稳定性略差。

这些缺点会导致多人协作时增加出错的几率和追踪代码历史的成本。

我上家公司在进行 Git 分支管理时采用了历经考验的更为成熟的 Git Flow 分支模型。它定义了 5 种分支，将职责更加细分：

| 分支 | 来源 | 说明 |
| --- | --- | --- |
| `master` | - | 用于存储正式发布的历史，每次发布都应该打上标签来标记已发布的版本 |
| `develop` | `master` | 集成了所有已开发完成的功能，包括尚未上线的 |
| `feature` | `develop` | 用于开发新的功能，开发并自测完要合并回 `develop` 分支 |
| `release` | `develop` | 囊括所有要发布的内容，不允许将不发布的功能包含在内，测试和修复 bug 都要在这个分支上进行，发布完需将代码合并到 `master` 分支并合并回 `develop` 分支 |
| `hotfix` | `master` | 用于修复线上 bug 做紧急发布，发布完需合并回 `master` 分支并合并到 `develop` 分支 |
{:.table.table-bordered}

小伙伴儿们在了解了这个分支模型能够轻松应对绝大部分复杂的多人协作场景的优势之后，纷纷表示可以先在团队内部试用一下。

### 样式源码编写

由于前公司所使用的 web 框架是 Ruby on Rails（下文简称为「rails」），在做前端的技术选型时会优先考虑与其生态融合较好的，像用 CoffeeScript 写脚本，用 Sass 写样式。

CoffeeScript 和 Sass 的 `.sass` 用的都是缩进语法，不允许任何尖括号和花括号等让代码看起来很「脏」的符号，对于没有接触过 rails 生态的人来说较难适应。另外，CoffeeScript 对其他团队成员来说算是个新语言了，具有一定学习成本，并且业界的趋势是用 ES 新语法，故不打算引入 CoffeeScript。

Sass 有两套语法，除了缩进语法外，还有一套与 CSS 完全兼容的 SCSS 语法，其文件扩展名为 `.scss`。使用这套语法的话，可以先将 `.css` 无缝升级到 `.scss`，然后再慢慢享用 Sass 的变量、函数、mixin 和条件判断等特性带来的高效、便捷。

之所以选择 Sass 而不是 LESS 或 Stylus，还有个原因，就是在使用 Sass 上我已经有一些代码和经验的积累可以直接拿来用。

确定了「用什么去写」之后，决定「如何去写」是另一个重要的话题。

写样式时尽可能使用 `class` 替代 `id` 和标签已经是约定俗成的最佳实践。在做页面开发时，可以将一个页面看成是由 N 个相对独立的组件拼成的，从这点来看，没有什么命名法比「[BEM](http://bem.info/){:target="_blank"}{:rel="nofollow external"}」更适合命名 `class` 的了。在各个 BEM 的变体当中，个人认为「[SUIT CSS 命名方式](https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md){:target="_blank"}{:rel="nofollow external"}」是可读性最好的。虽然使用 BEM 命名会使 `class` 变得比较长，但得益于 Sass 中的[父选择器 `&`](https://sass-lang.com/documentation/style-rules/parent-selector){:target="_blank"}{:rel="nofollow external"}，在开发时基本可以忽略这点。

经过讨论，一致决定样式源码使用 Sass 基于 SUIT CSS 命名方式去写并作为前端开发规范的一部分，这样会大大提高开发及协作效率。事后我将相关内容总结成文档沉淀到内网的 Confluence 上。

## 团队用命令行工具

鉴于 `shanshan` 的臃肿程度和「前后端分离」的开发方式，要立刻改变是不大可能的，但我这种「懒」且「怕麻烦」的人实在是不想继续忍受每次把静态资源文件上传到 OSS 都需要反复手动修改路径等信息的日子了……同时，考虑到日后使团队的开发流程规范化，一个自研的团队内统一使用的命令行工具是必不可少的！

命令行工具的名字叫「[Bumblebee](https://www.npmjs.com/package/b3){:target="_blank"}{:rel="nofollow external"}」，由于单词中有 3 个「b」，故简称「b3」。起这个名字是因为当时喜欢最新款的科迈罗，在《变形金刚 4》里大黄蜂所变形成的车就是科迈罗，大黄蜂的英文名是「Bumblebee」。

它主要支持两个命令：`init` 和 `upload`。

### `b3 init`

`init` 命令从名字来看就知道是个跟「初始化」相关的。

现在来看，这个命令的职责不是那么「纯正」，因为会根据有无参数而在当前工作目录对不同的目标主体进行操作：无参数时生成命令行工具的配置文件，有参数则按照指定的脚手架生成目录文件。

该命令的脚手架功能并不是自己实现的，而是做为一个外壳集成了脚手架工具 [Yeoman](https://yeoman.io/){:target="_blank"}{:rel="nofollow external"} 的底层库 [`yeoman-environment`](https://github.com/yeoman/environment){:target="_blank"}{:rel="nofollow external"} 来利用已经存在的大量的 [Yeoman generator](https://yeoman.io/generators/){:target="_blank"}{:rel="nofollow external"}。并且，我们所使用的活动页模板也是基于 Yeoman 自己开发的一个 generator。

### `b3 upload`

`upload` 命令用于将文件上传到 OSS 服务提供商，该命令是把 leader 写的上传文件脚本重构并优化、扩展而来。

与之前相比，具备了一个命令行工具该有的一些特性，如：初始化并生成配置文件；执行命令时传入选项以覆盖默认配置。更为重要的一个改进是，除了可以上传到七牛外，还能够备份到[顽兔](https://wantu.taobao.com){:target="_blank"}{:rel="nofollow external"}以备七牛挂掉时进行静态资源地址切换。

在后期的使用中，上传大量文件时会出现上传失败的情况。我猜是因为 OSS 服务提供商在短时间内接收到大量请求时做了限制，或者就是服务能力无法处理。后来我将上传文件的逻辑做了修改，把大批量的文件切分成 n 个「片段」以控制单位时间内的请求次数，粒度可以自定义，当一个「片段」中的文件全部上传完之后才会进行下一个。

## 推广 Git Flow

在前端小伙伴儿们基本都适应 Git Flow 这种方式时，我觉得是时候开始向整个技术部门推广了。

随着开发人员的增多，因为不是每个人都对 Git 使用熟练，在提交代码与合并分支时问题频出，突显出了 Git 及 Git Flow 培训的重要性。每每在与分支管理方面出现问题时，我就会在群里说一次 Git Flow 的事情。

有几次负责管理分支的鱼蛋找到我，讨论 Git Flow 的场景应变能力。可能是他也觉得用 Git Flow 会比现行方案强很多，在了解了相关知识后，挑了内网刚搭建好 GitLab 没几天的日子向整个技术部门普及 Git Flow 并讲解 GitLab 和 SourceTree 的用法。

为了让大家有文字参考，我写了份相关文档。在分享会上，鱼蛋对照着文档讲解了 Git 的一些常用操作，以及 Git Flow 的基本概念；我说明了如何用 SourceTree 结合 GitLab 实行 Git Flow，并讨论了到底该怎么去实施 Git Flow。事后，我将文档完善了下，形成了《[团队中的 Git 实践](/posts/working-with-git-in-team/){:target="_blank"}》这篇文章。

经过几个月的实践，技术部门对 Git Flow 的使用越来越规范，也越来越重视，甚至成为是否能够继续留在公司工作的衡量标准——新入职的人如果在培训后还搞不懂 Git Flow，将会被「升级」。

## 前端工程优化

作为一名前端工程师，在看到一些视觉上看着还不错的网站，尤其是有点名气的公司的产品时都会习惯性地打开浏览器的开发者工具，看看这个网站的前端都使用了哪些技术，以揣测这家公司的前端团队的实力和技术栈。

毫无掩盖地说，在我刚入职时，公司的网站虽然在访问、使用上没什么问题，但前端工程真是烂得一塌糊涂……并且，按照当时的开发方式，在写跟 Java 项目结合的页面时得开代理，每个人都得去配置代理规则；把图片上传到 OSS 需要反复手动修改路径等信息……简直是麻烦得不得了！

那时已经债台高筑了，想在原来的基础上进行修改也不是不可以，但改动的代价很大，最好是能够推倒重来，不过不太现实。还好，不久之后公司业务方向转变，要做一个新的 to B 的产品，给了我从头开始的机会！

在做新的项目时，为了调试方便和模块化管理，我们决定将前、后端代码放到一个仓库中；为了提高编码效率和复用性，并能够让每个人都跟得上时代的步伐，采用 Sass 编写样式表，使用 ES6 编写脚本；考虑到不同环境中静态资源的地址不同，在发布时需要自动替换掉模板中的资源引用地址，于是选择了 FIS3 作为构建工具。搭配上一些编码、文件等规范，感觉变得正规了不少！

在快一年的实践中，证明了这套方案可行，但还有些许不足——

针对基于 Java 框架的项目，FIS3 在 JS 的模块化方面支持得不是很好。虽说开发 FIS3 的团队做了一个名为 [fis3-jello](https://github.com/fex-team/fis3-jello) 的相关解决方案，但不太适合我们的项目。

页面中用的静态资源文件都是未经压缩的，整个页面的脚本文件都快以「m」为单位了，因为 Java 项目在部署时并未接入前端文件的构建流程。为了解决这个问题，我给团队用的命令行工具 [bumblebee](https://github.com/ourai/bumblebee) 添加了 `upload` 和 `publish` 命令用于将构建后的静态资源文件上传到 OSS。

问题解决是解决了，可因为各种原因还没有集成进发布系统。再加上没多久就要去做前后端分离的事情了，一时觉得没什么必要去弄了。

## 前后端分离

「前后端分离」是个老话题，也是一个经久不衰的话题。

有人觉得这种事情没必要去做，作为前端工程师就应该去了解甚至学会任职公司所使用的后端语言。可我觉得，虽然说是具体情况具体分析，但绝大部分情况需要分离。此举可令前后端工程师关系和睦，不浪费彼此生命；还能使前端的架构方式足够灵活，让前端工程师大展拳脚。另外，前端工程师可以去懂后端语言，但这应该是非强制性的。

起初为什么要搞前后端分离已经记不清了，应该是各种各样让人无力吐槽的蛋疼事情促使大家达成了一致的想法。并且，如果这件事情办成了，将会为前端团队打开一个新的局面。

团队里还没人做过这事，对于我们来说都很新鲜，这是一个探索、学习的过程。至于让谁去做，鉴于其他人当时都在研究 React Native，就交给了正在尝试用 Node.js 去做服务端开发的我。

说实话，在刚做的时候，我处于懵逼状态，该怎么进行下去，有些一头雾水。与其想太多，不如先把手动起来，于是我照着原来 Spring 框架中的文件结构在新建的仓库中用 Express 框架「复制」了一下。

光能在本地跑起来没啥用，找同时负责测试和运维的鱼蛋商量，在发布系统上添加了这个实验性项目的入口。把我编写的 shell 脚本接入进去，点击「开始部署」按钮，看到一行行日志打印在页面上，一切那么行云流水～

## 平行进口车业务

## 业务转型

## 绝望
